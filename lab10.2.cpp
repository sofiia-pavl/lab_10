#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <fstream>
#include <string>
using namespace std;
void CreateTXT(char* fname) // створення файлу з введених рядків
{
	ofstream fout(fname); // відкрили файл для запису
	char ch; // відповідь користувача – чи продовжувати введення
	string s; // введений користувачем рядок
	do
	{
		cin.get(); // очищуємо буфер клавіатури – щоб не було символу
		cin.sync(); // "кінець рядка", який залишився після вводу числа
		cout << "enter line: "; getline(cin, s); // ввели рядок
		fout << s << endl; // записали його у файл
		cout << "continue? (y/n): "; cin >> ch;
	} while (ch == 'y' || ch == 'Y');
	cout << endl;
}
void PrintTXT(char* fname) 
{
	ifstream fin(fname); 
	string s;
	while (getline(fin, s)) 
	{
		cout << s << endl; 
	}
	cout << endl;
}
void SortTXT(char* fname, char* gname) // сортування рядків текстового файлу
{
	ofstream g(gname); // відкрили другий файл для запису
	string s, mins, z = ""; // s – прочитаний з файлу f рядок
	// mins – рядок, який вважається
	// найменшим
   // z - записаний у файл g рядок
	int k; // - вказує, чи є ще рядки, які слід
	// записати у файл g
	do // цикл запису мінімального рядка
	{ // з тих, які ще не записані у файл g
		k = 0; // обнуляємо лічильник рядків,
		// які слід записати
		ifstream f(fname); // відкрили перший файл для зчитування
		// тепер будемо читати файл з початку
		// цикл початку пошуку мінімального із ще не записаних рядків
		while (getline(f, s)) // поки можна зчитувати рядки
		{
			if (s <= z) // якщо цей рядок вже записаний у файл g
				continue; // - пропускаємо його
			mins = s; // вважаємо перший ще не записаний рядок
			// - мінімальним
			k++; // знайшли ще не записаний рядок
			// - збільшили лічильник
			break; // вийшли з циклу присвоєння змінній
		} // mins початкового значення
		// цикл пошуку мінімального із ще не записаних рядків
		while (getline(f, s)) // поки можна зчитувати рядки
		{
			if (s <= z) // якщо цей рядок вже записаний у файл g
				continue; // - пропускаємо його
			if (s < mins) // якщо прочитаний рядок менши
			{ // мінімального
				mins = s; // - вважаємо його мінімальним
				k++; // збільшили лічильник ще не записаних
			} // рядків
		}
		// запис мінімального з не записаних рядків у файл g
		z = mins; // будемо записувати знайдений
		// мінімальний з не записаних рядків
		if (k > 0) // якщо були знайдені ще не записані
			g << z << endl; // рядки - записуємо мінімальний з них
		f.close(); // закрили перший файл
	} // щоб потім читати файл з початку
	while (k > 0); // повторюємо, поки є не записані рядки
}
void Remove(char* fname)
{
		ifstream f(fname);
	ofstream t("TMP.TXT");
	int x;
	while (f >> x) // скануємо заданий файл
		if (x >= 0) // і копіюємо ті компоненти,
			t << x << endl; // які потрібно залишити
	f.close(); // для вилучення і перейменування
	t.close(); // файли мають бути закриті
	remove(fname); // знищуємо заданий файл
	rename("TMP.TXT", fname); // перейменовуємо тимчасовий файл
}
int main()
{
	
	char fname[100]; 
	cout << "enter file name 1: "; cin >> fname;
	CreateTXT(fname); 
	PrintTXT(fname); 
	char gname[100]; // ім'я другого файлу
	cout << "enter file name 2: "; cin >> gname;
	SortTXT(fname, gname); // відсортували рядки першого файлу,
	// результат записали у другий файл
	PrintTXT(gname); // вивели вміст другого файлу на екран
	Remove(fname);
	PrintTXT(fname);
	return 0;
}